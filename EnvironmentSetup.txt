Preparing for the build:
The GNU Compiler Collection is an advanced piece of software with dependencies. You need the following in order to build GCC:

A Unix-like environment (Windows users can use the Windows Subsystem for Linux or Cygwin)
Enough memory and hard disk space (it depends, 256 MiB will not be enough).
GCC (existing release you wish to replace), or another system C compiler
G++ (if building a version of GCC >= 4.8.0), or another system C++ compiler
Make
Bison
Flex
GMP
MPFR
MPC
Texinfo
ISL (optional)

-------------------------------------------------------------------
export PREFIX="$HOME/opt/cross"
export TARGET=i686-elf
export PATH="$PREFIX/bin:$PATH"
cd $HOME/src

mkdir build-binutils
cd build-binutils
../binutils-x.y.z(2.41)/configure --target=$TARGET --prefix="$PREFIX" --with-sysroot --disable-nls --disable-werror
make
make install
cd $HOME/src

# The $PREFIX/bin dir _must_ be in the PATH. We did that above.
which -- $TARGET-as || echo $TARGET-as is not in the PATH

mkdir build-gcc
cd build-gcc
../gcc-x.y.z(13.2.0)/configure --target=$TARGET --prefix="$PREFIX" --disable-nls --enable-languages=c,c++ --without-headers --disable-hosted-libstdcxx
make all-gcc
make all-target-libgcc
make all-target-libstdc++-v3
make install-gcc
make install-target-libgcc
make install-target-libstdc++-v3

Now you have a "naked" cross-compiler. It does not have access to a C library or C runtime yet, so you cannot use most of the standard includes or create runnable binaries. But it is quite sufficient to compile the kernel you will be making shortly. Your toolset resides in $HOME/opt/cross (or what you set $PREFIX to). For example, you have a GCC executable installed as $HOME/opt/cross/bin/$TARGET-gcc, which creates programs for your TARGET.
You can now run your new compiler by invoking something like:
	$HOME/opt/cross/bin/$TARGET-gcc --version
To use your new compiler simply by invoking $TARGET-gcc, add $HOME/opt/cross/bin to your $PATH by typing:
	export PATH="$HOME/opt/cross/bin:$PATH"

-------------------------------------------------------------------
sudo apt update  
sudo apt install -y build-essential bison flex libgmp3-dev libmpc-dev libmpfr-dev texinfo libisl-dev wget curl  

export PREFIX="$HOME/opt/cross"  
export TARGET=i686-elf  
export PATH="$PREFIX/bin:$PATH"  

echo 'export PREFIX="$HOME/opt/cross"' >> ~/.bashrc  
echo 'export TARGET=i686-elf' >> ~/.bashrc  
echo 'export PATH="$PREFIX/bin:$PATH"' >> ~/.bashrc  
source ~/.bashrc  

mkdir -p $HOME/src  
cd $HOME/src  

wget https://ftp.gnu.org/gnu/binutils/binutils-2.41.tar.gz  
tar -xvzf binutils-2.41.tar.gz  

wget https://ftp.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.gz  
tar -xvzf gcc-13.2.0.tar.gz  

mkdir -p $HOME/src/build-binutils  
cd $HOME/src/build-binutils  
../binutils-2.41/configure --target=$TARGET --prefix="$PREFIX" --with-sysroot --disable-nls --disable-werror  
make -j$(nproc)  
make install  

mkdir -p $HOME/src/build-gcc  
cd $HOME/src/build-gcc  
../gcc-13.2.0/configure --target=$TARGET --prefix="$PREFIX" --disable-nls --enable-languages=c,c++ --without-headers --disable-hosted-libstdcxx  
make all-gcc -j$(nproc)  
make all-target-libgcc -j$(nproc)  
make all-target-libstdc++-v3 -j$(nproc)  
make install-gcc  
make install-target-libgcc  
make install-target-libstdc++-v3  

which -- $TARGET-gcc || echo "$TARGET-gcc is not in the PATH"  
$TARGET-gcc --version

-------------------------------------------------------------------
Troubleshooting
In general, verify that you read the instructions carefully and typed the commands precisely. Don't skip instructions. You will have to set your PATH variable again if you use a new shell instance, if you don't make it permanent by adding it to your shell profile. If a compilation seems to have gotten really messed up, type make distclean, and then start the make process over again. Ensure your un-archiever doesn't change newline characters.

ld: cannot find -lgcc
You specified that you want to link the GCC low-level runtime library into your executable through the -lgcc' switch, but forgot to build and properly install the library.
If you got no warnings or errors while installing libgcc and you still have problems you can copy the library in your project and link it with -L. -lgcc
The libgcc is at $PREFIX/lib/gcc/$TARGET/<gcc-version>/libgcc.a .

Binutils 2.9
What's alphabetically on the top or bottom is not necessarily the latest version. After 2.9 comes 2.10, 2.11, 2.12 and then there are more releases that are all newer and progressively more likely to build or support your choice of GCC version.

Building GCC: the directory that should contain system headers does not exist
You might encounter this error when building mingw32 targets, for example x86_64-w64-mingw32. The offending directory that can't be found is $SYSROOT/mingw/include. If you look in your sysroot, you will, of course, realise that no such folder exists.

The solution is simply to create the empty folders:

mkdir -p $SYSROOT/mingw/include
mkdir -p $SYSROOT/mingw/lib
This will allow the build to proceed. The reason this happens is that the mingw32 (and mingw itself) configures INCLUDE_PATH and LIBRARY_PATH to be, as can be guessed, /mingw/include and /mingw/lib, instead of the defaults /usr/include and /usr/lib. Why the build fails even though nothing is required in those folders, and why it doesn't just make them, is beyond me.

GCC libsanitizer failing to build
Sometimes GCC can't build libsanitizer, if that happens append --disable-libsanitizer to the configure command.
This only applies for building a hosted compiler.

---------------------------------------------------------------------
What order to work in - For the starter
Printing strings and integer numbers (both decimal and hex) on the screen is certainly a must. This is one of most basic ways of debugging, and virtually all of us have gone through a kprint() or kout in version 0.1.0.
Outputting to a serial port will save you a lot of debugging time. You don't have to fear losing information due to scrolling. You will be able to test your OS from a console, filter interesting debug messages, and automatize some tests.
Having a working and reliable interrupt/exception handling system that can dump the contents of the registers (and perhaps the address of the fault) will be very useful.
Plan your memory map (virtual, and physical) : decide where you want the data to be
The heap: allocating memory at runtime (malloc and free) is almost impossible to go without. It should be implemented as soon as possible.
Once those steps are completed, whether you'll try to have a working GUI before you have a filesystem, multitasking or module-loading is completely up to you. Try to sketch out what is likely to depend on what, and do things in 'least dependent first' order.

For instance, the GUI could depend on the filesystem to load bitmaps or resources, but you don't necessarily need bitmaps in your very first GUI. Good advice in such a case is to design the interface of the filesystem first (be it open/close/read/write or something else), and then go on with whatever you prefer, respecting the interface on both sides.